<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Path Planning By Rapidly Exploring Random Trees</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="/stylesheets/color-scheme.css"/>
<link rel="stylesheet" type="text/css" href="/stylesheets/layout-blog.css"/>
<link rel="stylesheet" type="text/css" href="/stylesheets/blog-post.css"/>
<link rel="stylesheet" type="text/css" href="/stylesheets/htmlize2.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script src="/javascripts/htmlize.js"></script>
<link rel="stylesheet" type="text/css" href="./path-finding.css"/>
<script src="//cdn.jsdelivr.net/npm/bluebird@3.7.2/js/browser/bluebird.min.js"></script>
<script type="module" src="./path-finding.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="preamble" class="status">
<header>
    <nav>
        <a target="_self" href="/">About</a> -
        <a target="_self" href="/blog-posts.html">Blog</a> |
        <!-- <a target="_self" href="/portfolio.html">Portfolio</a> -         -->
        <!-- <a target="_self" href="/contact.html">Contact</a> - -->
        <!-- <a target="_self" href="/resume.html">Resume</a> | -->
        <a target="_blank" rel="noopener noreferrer" href="https://duncan-britt.github.io/splice-docs">Splice</a> -
        <a target="_blank" rel="noopener noreferrer" href="https://word-ladders.herokuapp.com/">Word Ladders</a>
        <!-- <a target="_blank" rel="noopener noreferrer" href="https://github.com/Duncan-Britt/">GitHub</a> -
             <a target="_blank" rel="noopener noreferrer" href="https://www.codewars.com/users/Duncan-Britt">Code Wars</a> -->
    </nav>
</header>
</div>
<div id="content" class="content">
<h1 class="title">Path Planning By Rapidly Exploring Random Trees</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgf978325">Overview</a></li>
<li><a href="#org259f752">Canvas</a></li>
<li><a href="#org4569861">Event Handling</a></li>
<li><a href="#orge97c7cf">Path Planning</a>
<ul>
<li><a href="#org9cd4c6d">Dealing With Obstacles</a></li>
</ul>
</li>
<li><a href="#orge315482">Source Code</a></li>
</ul>
</div>
</div>
<p>
In my last blog post, I demonstrated the A* path planning algorithm. In this blog post, we're going to go through a sampling based approach called Rapidly Exploring Random Trees (RRT).
</p>


<div id="orgb598552" class="figure">
<p><img src="./RRT.gif" alt="RRT.gif" style="width: 200px;height: auto;" />
</p>
<p><span class="figure-number">Figure 1: </span>Demo</p>
</div>

<div>    
    <label for="instant" style="float: left;">Instant?</label>
    <input type="checkbox" id="instant" name="instant"/>
    <br/>    
    <input type="range" id="speed" name="volume" min="2" max="8" value="5" style="display: block;"/>
    <label for="speed">Speed</label>    
</div>
<div id="grid-container" style="position: relative; height: 420px"></div>

<div id="outline-container-orgf978325" class="outline-2">
<h2 id="orgf978325">Overview</h2>
<div class="outline-text-2" id="text-orgf978325">
<p>
Given a desired end position and starting position, RRT allows us to find a path connecting those two points. We start by randomly sampling a point on the plane. From there, we find the node in our tree which is closest to our sampled node. (At first, this is just the starting point). Then, having found that node, we move from it a short distance in the direction of the sampled node, until we either run into an obstacle or reach a maximum branch length. There, we'll place a child node. As you can see in the above demonstration, this has the effect of drawing out our tree to cover the space. We keep doing this until we are able to place a node within a certain threshold of distance to our desired destination.
</p>
</div>
</div>

<div id="outline-container-org259f752" class="outline-2">
<h2 id="org259f752">Canvas</h2>
<div class="outline-text-2" id="text-org259f752">
<p>
We're going to implement the following interface which allows us to render the above demo of RRT in a given HTML container.
</p>
<div class="org-src-container">
<pre class="src src-js" id="org0dab114"><span class="linenr">14: </span>  document.addEventListener(<span class="org-string">"DOMContentLoaded"</span>, () =&gt; {
<span class="linenr">15: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">width</span> = window.innerWidth &gt; 450 ? 400 : window.innerWidth - 50;
<span class="linenr">16: </span>    CanvasRRT({
<span class="linenr">17: </span>      canvas_container: document.querySelector(<span class="org-string">'#grid-container'</span>),
<span class="linenr">18: </span>      width: window.innerWidth &gt; 450 ? 400 : window.innerWidth - 75,
<span class="linenr">19: </span>      height: 400,
<span class="linenr">20: </span>      objects: [
<span class="linenr">21: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 10, y: 391 }, radius: 10, border_color: <span class="org-string">"#d63230"</span>, border_width: 0}),
<span class="linenr">22: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: width - 40, y: 10 }, radius: 10, border_color: <span class="org-string">"#d63230"</span>, border_width: 0}),
<span class="linenr">23: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 294, y: 150 }, radius: 40, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>}),
<span class="linenr">24: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 164, y: 269 }, radius: 40, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>}),
<span class="linenr">25: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 179, y: 152 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">26: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 69, y: 80 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">27: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 138, y: 67 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">28: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 217, y: 92 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">29: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 306, y: 64 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">30: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 261, y: 231 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">31: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 340, y: 241 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">32: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 310, y: 365 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">33: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 248, y: 310 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">34: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 66, y: 160 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">35: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 65, y: 249 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">36: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 97, y: 323 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">37: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 183, y: 343 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">38: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 125, y: 195 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">39: </span>        <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 325, y: 322 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr">40: </span>      ],
<span class="linenr">41: </span>      speed_slider: document.querySelector(<span class="org-string">'input#speed'</span>),
<span class="linenr">42: </span>      instant_checkbox: document.getElementById(<span class="org-string">'instant'</span>),
<span class="linenr">43: </span>    });
<span class="linenr">44: </span>  });
</pre>
</div>
<p>
We specified the DOM elements for our container and speed slider, as well as the dimensions of the canvas and the obstacles we'd like to populate our canvas with, which are all circles in this example.
</p>

<div class="org-src-container">
<pre class="src src-js" id="org2ce10f5"><span class="linenr">48: </span>  <span class="org-keyword">class</span> Circle {
<span class="linenr">49: </span>    constructor({ center, radius, border_color, border_width=4, fill_color=border_color }) {
<span class="linenr">50: </span>      <span class="org-constant">this</span>.center = center;
<span class="linenr">51: </span>      <span class="org-constant">this</span>.radius = radius;
<span class="linenr">52: </span>      <span class="org-constant">this</span>.border_color = border_color;
<span class="linenr">53: </span>      <span class="org-constant">this</span>.fill_color = fill_color;
<span class="linenr">54: </span>      <span class="org-constant">this</span>.border_width = border_width;
<span class="linenr">55: </span>    }
<span class="linenr">56: </span>
<span class="linenr">57: </span>    within(x, y) {
<span class="linenr">58: </span>      <span class="org-keyword">return</span> distance({ x, y }, <span class="org-constant">this</span>.center) &lt;= <span class="org-constant">this</span>.radius;
<span class="linenr">59: </span>    }
<span class="linenr">60: </span>  }
<span class="linenr">61: </span>
<span class="linenr">62: </span>  <span class="org-keyword">function</span> <span class="org-function-name">distance</span>(<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>) {
<span class="linenr">63: </span>    <span class="org-keyword">return</span> Math.sqrt(Math.pow(b.y - a.y, 2) + Math.pow(b.x - a.x, 2));
<span class="linenr">64: </span>  }
</pre>
</div>

<p>
First, we're going to set up our HTML canvases. The second canvas acts as a top layer for placing temporary drawings. This way, when we animate the algorithm, we can erase the sampled points by clearing <code>layer2</code>.
</p>
<div class="org-src-container">
<pre class="src src-js" id="org34d32d7"><span class="linenr"> 89: </span><span class="org-keyword">async</span> <span class="org-keyword">function</span> CanvasRRT ({ canvas_container, width, height, objects, speed_slider, instant_checkbox }) {
<span class="linenr"> 90: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">canvas</span> = document.createElement(<span class="org-string">'canvas'</span>);
<span class="linenr"> 91: </span>  canvas.style.border = <span class="org-string">"6px solid black"</span>;
<span class="linenr"> 92: </span>  canvas.style.touchAction = <span class="org-string">'none'</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Prevent scroll on touch screen devices.</span>
<span class="linenr"> 93: </span>  canvas.width = width;
<span class="linenr"> 94: </span>  canvas.height = height;
<span class="linenr"> 95: </span>  canvas.style.position = <span class="org-string">"absolute"</span>;
<span class="linenr"> 96: </span>  canvas.style.left = 0;
<span class="linenr"> 97: </span>  canvas.style.top = 0;
<span class="linenr"> 98: </span>  canvas.style.zIndex = 0;
<span class="linenr"> 99: </span>
<span class="linenr">100: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">layer2</span> = document.createElement(<span class="org-string">'canvas'</span>);
<span class="linenr">101: </span>  layer2.style.border = <span class="org-string">"6px solid black"</span>;
<span class="linenr">102: </span>  layer2.style.touchAction = <span class="org-string">'none'</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Prevent scroll on touch screen devices.</span>
<span class="linenr">103: </span>  layer2.width = width;
<span class="linenr">104: </span>  layer2.height = height;
<span class="linenr">105: </span>  layer2.style.position = <span class="org-string">"absolute"</span>;
<span class="linenr">106: </span>  layer2.style.left = 0;
<span class="linenr">107: </span>  layer2.style.top = 0;
<span class="linenr">108: </span>  layer2.style.zIndex = 1;
<span class="linenr">109: </span>
<span class="linenr">110: </span>  canvas_container.appendChild(canvas);
<span class="linenr">111: </span>  canvas_container.appendChild(layer2);
<span class="linenr">112: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">cx</span> = canvas.getContext(<span class="org-string">"2d"</span>);
<span class="linenr">113: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">cx2</span> = layer2.getContext(<span class="org-string">"2d"</span>);
</pre>
</div>
<p>
The <code>cx</code> (and <code>cx2</code>) object is what we will manipulate to draw on our canvas.
</p>
</div>
</div>

<div id="outline-container-org4569861" class="outline-2">
<h2 id="org4569861">Event Handling</h2>
<div class="outline-text-2" id="text-org4569861">
<p>
Next up, we're going to need a way to respond to user events.
</p>

<div class="org-src-container">
<pre class="src src-js" id="org6fd1777"><span class="linenr">366: </span>  layer2.addEventListener(<span class="org-string">'mousedown'</span>, press_handler, <span class="org-constant">true</span>);
<span class="linenr">367: </span>  layer2.addEventListener(<span class="org-string">'pointerdown'</span>, press_handler, <span class="org-constant">true</span>);
<span class="linenr">368: </span>  layer2.addEventListener(<span class="org-string">'mousemove'</span>, move_handler, <span class="org-constant">true</span>);
<span class="linenr">369: </span>  layer2.addEventListener(<span class="org-string">'pointermove'</span>, move_handler, <span class="org-constant">true</span>);
<span class="linenr">370: </span>  window.addEventListener(<span class="org-string">'mouseup'</span>, unclick_handler, <span class="org-constant">true</span>);      
<span class="linenr">371: </span>  window.addEventListener(<span class="org-string">'pointerup'</span>, unclick_handler, <span class="org-constant">true</span>);
</pre>
</div>

<p>
We want the canvas to be continuously re-rendered if the use is dragging an object, and we want to recalculate the path from A to B whenever the user clicks or finishes dragging an object. We'll also update the cursor depending on the context.
</p>

<div class="org-src-container">
<pre class="src src-js" id="orgc8ea3ce"><span class="linenr">136: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">object_grabbed_idx</span> = -1;
<span class="linenr">137: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">object_hovered_idx</span> = -1;
<span class="linenr">138: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">clicked_on</span> = <span class="org-constant">false</span>;
<span class="linenr">139: </span>
<span class="linenr">140: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">press_handler</span> = e =&gt; {
<span class="linenr">141: </span>    e.stopPropagation();
<span class="linenr">142: </span>    e.preventDefault();
<span class="linenr">143: </span>    clicked_on = <span class="org-constant">true</span>;
<span class="linenr">144: </span>    object_grabbed_idx = objects.reduce((res, object, current_idx) =&gt; {
<span class="linenr">145: </span>      <span class="org-keyword">return</span> object.within(e.offsetX, e.offsetY) ?  current_idx : res;
<span class="linenr">146: </span>    }, -1); <span class="org-comment-delimiter">// </span><span class="org-comment">-1 indicates no object grabbed</span>
<span class="linenr">147: </span>
<span class="linenr">148: </span>    object_hovered_idx = object_grabbed_idx;
<span class="linenr">149: </span>    <span class="org-keyword">if</span> (object_grabbed_idx != -1) {
<span class="linenr">150: </span>      layer2.style.cursor = <span class="org-string">"grabbing"</span>;
<span class="linenr">151: </span>    }
<span class="linenr">152: </span>  };
<span class="linenr">153: </span>
<span class="linenr">154: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">move_handler</span> = e =&gt; {
<span class="linenr">155: </span>    e.stopPropagation();
<span class="linenr">156: </span>    e.preventDefault();
<span class="linenr">157: </span>
<span class="linenr">158: </span>    <span class="org-keyword">if</span> (object_grabbed_idx == -1) {
<span class="linenr">159: </span>      object_hovered_idx = objects.reduce((res, object, current_idx) =&gt; {
<span class="linenr">160: </span>        <span class="org-keyword">return</span> object.within(e.offsetX, e.offsetY) ?  current_idx : res;
<span class="linenr">161: </span>      }, -1); <span class="org-comment-delimiter">// </span><span class="org-comment">-1 indicates no object hovered over</span>
<span class="linenr">162: </span>      <span class="org-keyword">if</span> (object_hovered_idx == -1) {
<span class="linenr">163: </span>        layer2.style.cursor = <span class="org-string">"crosshair"</span>
<span class="linenr">164: </span>      } <span class="org-keyword">else</span> {
<span class="linenr">165: </span>        layer2.style.cursor = <span class="org-string">"grab"</span>
<span class="linenr">166: </span>      }
<span class="linenr">167: </span>
<span class="linenr">168: </span>      <span class="org-keyword">return</span>;
<span class="linenr">169: </span>    }
<span class="linenr">170: </span>
<span class="linenr">171: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = e.offsetX;
<span class="linenr">172: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = e.offsetY;
<span class="linenr">173: </span>    <span class="org-keyword">if</span> (x &lt; 0 || y &lt; 0 || x &gt;= canvas.width || y &gt;= canvas.height) {
<span class="linenr">174: </span>      <span class="org-keyword">return</span>;
<span class="linenr">175: </span>    }
<span class="linenr">176: </span>
<span class="linenr">177: </span>    objects[object_grabbed_idx].center = { x, y };
<span class="linenr">178: </span>    render_grid();
<span class="linenr">179: </span>  };
</pre>
</div>

<p>
The path should be <a href="#coderef-RRT-call" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-RRT-call');" onmouseout="CodeHighlightOff(this, 'coderef-RRT-call');">recalculated</a> when the user releases the mouse/trackpad/etc&#x2026;. The path planning, especially when animated, may take some time, and while that is happening, we don't want the page to become unresponsive. Since JavaScript is single threaded, we have to interweave the execution of our path planning code asynchronously. For that, we're going to use the <code>Promise</code> API<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>. 
</p>
<div class="org-src-container">
<pre class="src src-js" id="org1ff6910"><span class="linenr">332: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">RRT_promise</span>;
<span class="linenr">333: </span>
<span class="linenr">334: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">unclick_handler</span> = e =&gt; {
<span class="linenr">335: </span>    <span class="org-keyword">if</span> (!clicked_on) { <span class="org-comment-delimiter">// </span><span class="org-comment">the user may be unclicking off      </span>
<span class="linenr">336: </span>      <span class="org-keyword">return</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">the canvas after clicking and </span>
<span class="linenr">337: </span>    }                  <span class="org-comment-delimiter">// </span><span class="org-comment">dragging on the canvas</span>
<span class="linenr">338: </span>
<span class="linenr">339: </span>    <span class="org-keyword">if</span> (RRT_promise) {
<span class="linenr">340: </span>      RRT_promise.cancel();
<span class="linenr">341: </span>    }
<span class="linenr">342: </span>
<span class="linenr">343: </span>    render_grid();
<span class="linenr">344: </span>    object_grabbed_idx = -1;
<span class="linenr">345: </span>    layer2.style.cursor = object_hovered_idx == -1 ? <span class="org-string">"crosshair"</span> : <span class="org-string">"grab"</span>;
<span class="linenr">346: </span>
<span id="coderef-RRT-call" class="coderef-off"><span class="linenr">347: </span>    RRT_promise = RRT();</span>
<span class="linenr">348: </span>    RRT_promise.then(err =&gt; {
<span class="linenr">349: </span>      <span class="org-keyword">if</span> (err == 0) {
<span class="linenr">350: </span>        cx.strokeStyle = <span class="org-string">"#d63230"</span>;
<span class="linenr">351: </span>        cx.lineWidth = 3; 
<span class="linenr">352: </span>        cx.lineJoin = <span class="org-string">"round"</span>;
<span class="linenr">353: </span>        cx.beginPath();
<span class="linenr">354: </span>        cx.moveTo(path[0].x, path[0].y);
<span class="linenr">355: </span>        path.forEach(node =&gt; {
<span class="linenr">356: </span>          cx.lineTo(node.x, node.y);
<span class="linenr">357: </span>        });
<span id="coderef-draw-path" class="coderef-off"><span class="linenr">358: </span>        cx.stroke();</span>
<span class="linenr">359: </span>      }
<span class="linenr">360: </span>    });
<span class="linenr">361: </span>
<span class="linenr">362: </span>    clicked_on = <span class="org-constant">false</span>;
<span class="linenr">363: </span>  };
</pre>
</div>
<p>
Following a successful path planning, we'll <a href="#coderef-draw-path" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-draw-path');" onmouseout="CodeHighlightOff(this, 'coderef-draw-path');">draw the path</a> on the canvas.
</p>

<p>
Here's the code used to render the grid whenever we reset it.
</p>
<div class="org-src-container">
<pre class="src src-js" id="orga3dab9a"><span class="linenr">115: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">render_grid</span> = () =&gt; {  
<span class="linenr">116: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">draw canvas background</span>
<span class="linenr">117: </span>    cx.fillStyle = BACKGROUND_COLOR; <span class="org-comment-delimiter">// </span><span class="org-comment">blue green</span>
<span class="linenr">118: </span>    cx.fillRect(0, 0, width, height);
<span class="linenr">119: </span>
<span class="linenr">120: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">draw objects</span>
<span class="linenr">121: </span>    objects.forEach(object =&gt; {
<span class="linenr">122: </span>      cx.beginPath();
<span class="linenr">123: </span>      <span class="org-comment-delimiter">// </span><span class="org-comment">center=(x,y) radius=r angle=0 to 7</span>
<span class="linenr">124: </span>      cx.arc(object.center.x, object.center.y, object.radius - object.border_width / 2, 0, 7);
<span class="linenr">125: </span>      cx.fillStyle = object.fill_color;    
<span class="linenr">126: </span>      cx.fill();
<span class="linenr">127: </span>
<span class="linenr">128: </span>      cx.lineWidth = object.border_width;
<span class="linenr">129: </span>      cx.strokeStyle = object.border_color;
<span class="linenr">130: </span>      cx.stroke();
<span class="linenr">131: </span>
<span class="linenr">132: </span>      cx.closePath();
<span class="linenr">133: </span>    });
<span class="linenr">134: </span>  }
</pre>
</div>
<p>
At this point, we're ready to dive into the algorithm.
</p>
</div>
</div>

<div id="outline-container-orge97c7cf" class="outline-2">
<h2 id="orge97c7cf">Path Planning</h2>
<div class="outline-text-2" id="text-orge97c7cf">
<p>
We begin by <a href="#coderef-sample" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-sample');" onmouseout="CodeHighlightOff(this, 'coderef-sample');">sampling</a> a random spot from the grid.
</p>
<div class="org-src-container">
<pre class="src src-js" id="orgac178d7"><span class="linenr">181: </span><span class="org-keyword">let</span> <span class="org-variable-name">path</span>;
<span class="linenr">182: </span><span class="org-keyword">const</span> <span class="org-variable-name">RRT</span> = () =&gt; {
<span class="linenr">183: </span>  <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">Promise</span>(<span class="org-keyword">async</span> (resolve, reject, onCancel) =&gt; {
<span class="linenr">184: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">MAX_BRANCH_LENGTH</span> = 20;
<span class="linenr">185: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">PROXIMITY_THRESHOLD</span> = 10;
<span class="linenr">186: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">MAX_ITERATIONS</span> = 5000;
<span class="linenr">187: </span>
<span class="linenr">188: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">path_nodes</span> = [<span class="org-keyword">new</span> <span class="org-type">PathNode</span>(objects[0].center.x, objects[0].center.y)];
<span class="linenr">189: </span>
<span class="linenr">190: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">iterations</span> = 0;
<span class="linenr">191: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">unfulfilled_promise</span> = <span class="org-constant">true</span>;
<span class="linenr">192: </span>    onCancel(<span class="org-keyword">function</span>() {
<span class="linenr">193: </span>      unfulfilled_promise = <span class="org-constant">false</span>;
<span class="linenr">194: </span>    });
<span class="linenr">195: </span>    <span class="org-keyword">while</span> (iterations &lt;= MAX_ITERATIONS &amp;&amp; unfulfilled_promise) {
<span class="linenr">196: </span>      <span class="org-comment-delimiter">// </span><span class="org-comment">randomly sample a point, (xs, ys) </span>
<span id="coderef-sample" class="coderef-off"><span class="linenr">197: </span>      <span class="org-keyword">let</span> [<span class="org-variable-name">xs</span>, <span class="org-variable-name">ys</span>] = [Math.random() * canvas.width, Math.random() * canvas.height];</span>
<span class="linenr">198: </span>
<span class="linenr">199: </span>      <span class="org-keyword">if</span> (!instant_checkbox.checked &amp;&amp; unfulfilled_promise) {
<span class="linenr">200: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">display sample spot</span>
<span class="linenr">201: </span>        <span class="org-keyword">let</span> <span class="org-variable-name">sample_circle</span> = <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: {x: xs, y: ys}, radius: 3, fill: <span class="org-constant">true</span>, border_color: <span class="org-string">"red"</span>});
<span class="linenr">202: </span>        cx2.beginPath(); 
<span class="linenr">203: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">center=(x,y) radius=r angle=0 to 7 </span>
<span class="linenr">204: </span>        cx2.arc(sample_circle.center.x, sample_circle.center.y, sample_circle.radius, 0, 7);
<span class="linenr">205: </span>        cx2.fillStyle = sample_circle.fill_color;
<span id="coderef-draw-sample" class="coderef-off"><span class="linenr">206: </span>        cx2.fill();</span>
<span class="linenr">207: </span>        cx2.closePath();
<span class="linenr">208: </span>      }
<span class="linenr">209: </span>
<span class="linenr">210: </span>      <span class="org-comment-delimiter">// </span><span class="org-comment">Find the nearest node in the tree</span>
<span id="coderef-find-nearest-node" class="coderef-off"><span class="linenr">211: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">nearest_node</span> = path_nodes.reduce((nearest, node) =&gt; {</span>
<span class="linenr">212: </span>        <span class="org-keyword">return</span> distance(node, { x: xs, y: ys }) &lt; distance(nearest, { x: xs, y: ys }) ? node : nearest;
<span class="linenr">213: </span>      });
</pre>
</div>
<p>
If the user sets the speed to anything less than 100%, we also <a href="#coderef-draw-sample" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-draw-sample');" onmouseout="CodeHighlightOff(this, 'coderef-draw-sample');">draw the point</a> on the second layer of our canvas. Then we then we need to <a href="#coderef-find-nearest-node" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-find-nearest-node');" onmouseout="CodeHighlightOff(this, 'coderef-find-nearest-node');">find the nearest node</a> in the tree.
</p>
</div>

<div id="outline-container-org9cd4c6d" class="outline-3">
<h3 id="org9cd4c6d">Dealing With Obstacles</h3>
<div class="outline-text-3" id="text-org9cd4c6d">
<p>
We now turn our attention to the task of deciding where to place our new node. We're going to put it in the direction of the sampled point, from our <code>nearest_node</code>. But we don't want to go very far at any given time. And we also don't want to place it within an obstacle, but we can go right up to the edge of an obstacle. We'll need a way to travel in the direction of the sampled point from our <code>nearest_node</code>. But we also need to be able to determine whether and where that line intersects with an obstacle. 
</p>

<p>
A line through points \(P\) and \(Q\) can be described parametrically as
</p>
\begin{align*}
\vec{r}(t) & = \vec{r_0} + t \frac{\vec{PQ}}{\|\vec{PQ}\|},
\end{align*}
<p>
where \(\vec{r_0}\) is the vector pointing to point \(P\), from the origin. Notice the \(\|\vec{PQ}\|\) in the denominator makes \(\frac{\vec{PQ}}{\|\vec{PQ}\|}\) a unit vector, which means that \(\vec{r}(t)\) is parameterized by the length of the line. This will come in handy. Let \(\vec{u}\) be the unit vector \(\frac{\vec{PQ}}{\|\vec{PQ}\|}\).
</p>
\begin{align*}
\vec{r}(t) & = \vec{r_0} + t\vec{u} \\
     & = \langle x_0, y_0 \rangle + t \langle u_x, u_y \rangle \\
     & = \langle u_xt + x_0, u_yt + y_0 \rangle
\end{align*}

<div class="org-src-container">
<pre class="src src-js" id="orgd20d27c"><span class="linenr">216: </span><span class="org-keyword">const</span> <span class="org-variable-name">dx</span> = xs - nearest_node.x;
<span class="linenr">217: </span><span class="org-keyword">const</span> <span class="org-variable-name">dy</span> = ys - nearest_node.y;
<span class="linenr">218: </span><span class="org-keyword">const</span> <span class="org-variable-name">magnitude</span> = Math.sqrt(dx**2 + dy**2);
<span class="linenr">219: </span><span class="org-keyword">const</span> <span class="org-variable-name">ux</span> = dx / magnitude;
<span class="linenr">220: </span><span class="org-keyword">const</span> <span class="org-variable-name">uy</span> = dy / magnitude;
<span class="linenr">221: </span><span class="org-comment-delimiter">// </span><span class="org-comment">r(t) is the vector equation of a line through the nearest node and the sampled point</span>
<span class="linenr">222: </span><span class="org-comment-delimiter">//        </span><span class="org-comment">&#9115;x &#9118;     &#9115;u &#9118;</span>
<span class="linenr">223: </span><span class="org-comment-delimiter">//        </span><span class="org-comment">&#9116; 0&#9119;     &#9116; x&#9119;</span>
<span class="linenr">224: </span><span class="org-comment-delimiter">// </span><span class="org-comment">r(t) = &#9116;  &#9119; + t &#9116;  &#9119;</span>
<span class="linenr">225: </span><span class="org-comment-delimiter">//        </span><span class="org-comment">&#9116;y &#9119;     &#9116;u &#9119;</span>
<span class="linenr">226: </span><span class="org-comment-delimiter">//        </span><span class="org-comment">&#9117; 0&#9120;     &#9117; y&#9120;</span>
<span class="linenr">227: </span>
<span class="linenr">228: </span><span class="org-keyword">const</span> <span class="org-variable-name">r</span> = t =&gt; {          
<span class="linenr">229: </span>  <span class="org-keyword">return</span> [ ux * t + nearest_node.x, uy * t + nearest_node.y ];
<span class="linenr">230: </span>};
</pre>
</div>

<p>
All of our obstacles are circles, and given the radius \(r_c\) and center of the circle \((C_x,C_y)\), we can write an equation for the circle in \(\mathbb{R}^2\):
\[(x - C_x)^2 + (y-C_y)^2 = r_c^2.\]
</p>

<p>
We need to find out if there is a point on the line that satisfies our equation for any of our circles, within a certain range of our parameter \(t\), which corresponds to the distance we want to travel from our existing node.
</p>

<p>
We can do this by substituting the \(\hat{x}\) and \(\hat{y}\) components of \(\vec{r}\) into the equation of each circle, and then solving for \(t\). If there are any real solutions, then our line cuts through the circle, and we know where.
\[\left(u_xt + x_{0} - C_{x} \right)^{2} + \left(u_yt + y_{0} - C_{y}\right)^{2} = r_{c}^{2}\]
Solving this equation by hand would get a little messy, but a few lines of python make short work of it.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> sympy <span class="org-keyword">import</span> symbols, expand, factor, latex, solve

<span class="org-variable-name">x0</span>, <span class="org-variable-name">ux</span>, <span class="org-variable-name">t</span>, <span class="org-variable-name">cx</span>, <span class="org-variable-name">y0</span>, <span class="org-variable-name">uy</span>, <span class="org-variable-name">cy</span>, <span class="org-variable-name">rc</span> <span class="org-operator">=</span> symbols(<span class="org-string">'x_0 u_x t C_x y_0 u_y C_y r_c'</span>)
<span class="org-variable-name">expr</span> <span class="org-operator">=</span> (ux<span class="org-operator">*</span>t <span class="org-operator">+</span> x0 <span class="org-operator">-</span> cx)<span class="org-operator">**</span>2 <span class="org-operator">+</span> (uy<span class="org-operator">*</span>t <span class="org-operator">+</span> y0 <span class="org-operator">-</span> cy)<span class="org-operator">**</span>2 <span class="org-operator">-</span> rc<span class="org-operator">**</span>2
<span class="org-variable-name">solutions</span> <span class="org-operator">=</span> solve(expr, t)
<span class="org-keyword">for</span> solution <span class="org-keyword">in</span> solutions:      
    <span class="org-builtin">print</span>(<span class="org-string">"$$"</span> <span class="org-operator">+</span> latex(solution) <span class="org-operator">+</span> <span class="org-string">"$$"</span>)
</pre>
</div>

<p>
\[\frac{C_{x} u_{x} + C_{y} u_{y} - u_{x} x_{0} - u_{y} y_{0} - \sqrt{- C_{x}^{2} u_{y}^{2} + 2 C_{x} C_{y} u_{x} u_{y} - 2 C_{x} u_{x} u_{y} y_{0} + 2 C_{x} u_{y}^{2} x_{0} - C_{y}^{2} u_{x}^{2} + 2 C_{y} u_{x}^{2} y_{0} - 2 C_{y} u_{x} u_{y} x_{0} + r_{c}^{2} u_{x}^{2} + r_{c}^{2} u_{y}^{2} - u_{x}^{2} y_{0}^{2} + 2 u_{x} u_{y} x_{0} y_{0} - u_{y}^{2} x_{0}^{2}}}{u_{x}^{2} + u_{y}^{2}}\]
\[\frac{C_{x} u_{x} + C_{y} u_{y} - u_{x} x_{0} - u_{y} y_{0} + \sqrt{- C_{x}^{2} u_{y}^{2} + 2 C_{x} C_{y} u_{x} u_{y} - 2 C_{x} u_{x} u_{y} y_{0} + 2 C_{x} u_{y}^{2} x_{0} - C_{y}^{2} u_{x}^{2} + 2 C_{y} u_{x}^{2} y_{0} - 2 C_{y} u_{x} u_{y} x_{0} + r_{c}^{2} u_{x}^{2} + r_{c}^{2} u_{y}^{2} - u_{x}^{2} y_{0}^{2} + 2 u_{x} u_{y} x_{0} y_{0} - u_{y}^{2} x_{0}^{2}}}{u_{x}^{2} + u_{y}^{2}}\]
</p>

<p>
This may look messy, but all of these values are known constants. We're looking for \(t\) values at points of intersection. First we are interested in whether the part <a href="#coderef-underoot" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-underoot');" onmouseout="CodeHighlightOff(this, 'coderef-underoot');">under the radical</a> is less than 0, because that would imply there is no solution, and that we can safely ignore the possibility of running into an obstacle.
</p>

<div class="org-src-container">
<pre class="src src-js" id="orgc481f26"><span class="linenr">232: </span><span class="org-keyword">let</span> <span class="org-variable-name">ts</span> = []; <span class="org-comment-delimiter">// </span><span class="org-comment">t values at intersections between r(t) and the circles</span>
<span class="linenr">233: </span><span class="org-keyword">if</span> (unfulfilled_promise) {
<span class="linenr">234: </span>  objects.slice(2).forEach(circle =&gt; {
<span class="linenr">235: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">cx</span> = circle.center.x;
<span class="linenr">236: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">cy</span> = circle.center.y;
<span class="linenr">237: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">x0</span> = nearest_node.x;
<span class="linenr">238: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">y0</span> = nearest_node.y;
<span class="linenr">239: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">rc</span> = circle.radius;
<span id="coderef-underoot" class="coderef-off"><span class="linenr">240: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">under_root</span> = -(cx**2) * uy**2 + 2 * cx * cy * ux * uy - 2 * cx * ux * uy * y0 + 2 * cx * uy**2 * x0 - cy**2 * ux**2 + 2 * cy * ux**2 * y0 - 2 * cy * ux * uy * x0 + ux**2 * rc**2 + rc**2 * uy**2 - ux**2 * y0**2 + 2 * ux * uy * x0 * y0 - uy**2 * x0**2;</span>
<span class="linenr">241: </span>    <span class="org-keyword">if</span> (under_root &lt; 0) {           
<span class="linenr">242: </span>      <span class="org-keyword">return</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no intersection</span>
<span class="linenr">243: </span>    }
</pre>
</div>

<p>
Next, we're going to evaluate and collect the solutions. We're only interested in solutions greater than 0 and less than the maximum distance we want to travel.
</p>
<div class="org-src-container">
<pre class="src src-js" id="org2bdc751"><span class="linenr">245: </span>      <span class="org-comment-delimiter">// </span><span class="org-comment">now we need to know if it has a solution on a range of t</span>
<span class="linenr">246: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = cx * ux + cy * uy - ux * x0 - uy * y0;
<span class="linenr">247: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">denom</span> = ux**2 + uy**2;
<span class="linenr">248: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">t1</span> = (a - Math.sqrt(under_root)) / denom;
<span class="linenr">249: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">t2</span> = (a + Math.sqrt(under_root)) / denom;
<span class="linenr">250: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">tsi</span> = [t1, t2];
<span class="linenr">251: </span>      tsi.forEach(t =&gt; {
<span class="linenr">252: </span>        <span class="org-keyword">if</span> (t &gt; 0 &amp;&amp; t &lt; MAX_BRANCH_LENGTH) {
<span class="linenr">253: </span>          ts.push(t);
<span class="linenr">254: </span>        }         
<span class="linenr">255: </span>      });
<span class="linenr">256: </span>    });  
<span class="linenr">257: </span>  }
</pre>
</div>

<p>
The \(t\) value we're going to use to place our actual node will be the minimum among the <code>MAX_BRANCH_LENGTH</code>, any solutions we found, and the distance between the nearest node and the sample node. To avoid errors associated with floating point numbers, we'll double check that the a node at this point won't lie within an obstacle, and we'll add the node to our path.
</p>

<div class="org-src-container">
<pre class="src src-js" id="org84b428d"><span class="linenr">259: </span><span class="org-keyword">let</span> <span class="org-variable-name">tn</span> = Math.min(...ts, MAX_BRANCH_LENGTH, distance(nearest_node, { x: xs, y: ys })) - 0.2;
<span class="linenr">260: </span>
<span class="linenr">261: </span><span class="org-keyword">if</span> (objects.slice(2).every(circle =&gt; !circle.within(...r(tn)))) {       
<span class="linenr">262: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">new_node</span> = <span class="org-keyword">new</span> <span class="org-type">PathNode</span>(...r(tn), nearest_node);
<span class="linenr">263: </span>  path_nodes.push(new_node);
</pre>
</div>
<p>
We'll also animate the branch joining the node. and draw the node on the canvas.
</p>
<div class="org-src-container">
<pre class="src src-js" id="org95f4060"><span class="linenr">265: </span><span class="org-keyword">if</span> (!instant_checkbox.checked) {
<span class="linenr">266: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">n_waypoints</span> = 2**(10-speed_slider.value);
<span class="linenr">267: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">waypoints</span> = calc_waypoints(nearest_node, new_node, n_waypoints);
<span class="linenr">268: </span>  <span class="org-keyword">for</span> (<span class="org-keyword">let</span> <span class="org-variable-name">t</span> = 1; t &lt; waypoints.length; t++) {
<span class="linenr">269: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">a</span> = waypoints[t-1];
<span class="linenr">270: </span>    <span class="org-keyword">const</span> <span class="org-variable-name">b</span> = waypoints[t];
<span class="linenr">271: </span>
<span class="linenr">272: </span>    <span class="org-keyword">await</span> sleep(0);
<span class="linenr">273: </span>    
<span class="linenr">274: </span>    requestAnimationFrame(_ =&gt; {
<span class="linenr">275: </span>      <span class="org-keyword">if</span> (unfulfilled_promise) {
<span class="linenr">276: </span>        cx.strokeStyle = TREE_COLOR;
<span class="linenr">277: </span>        cx.lineWidth = 1.2;
<span class="linenr">278: </span>        cx.beginPath();
<span class="linenr">279: </span>        cx.moveTo(a.x, a.y);
<span class="linenr">280: </span>        cx.lineTo(b.x, b.y);
<span class="linenr">281: </span>        cx.stroke();
<span class="linenr">282: </span>        cx.closePath();
<span class="linenr">283: </span>      }
<span class="linenr">284: </span>    });
<span class="linenr">285: </span>  }
<span class="linenr">286: </span>} <span class="org-keyword">else</span> {
<span class="linenr">287: </span>  <span class="org-keyword">if</span> (unfulfilled_promise) {
<span class="linenr">288: </span>    cx.strokeStyle = TREE_COLOR;
<span class="linenr">289: </span>    cx.lineWidth = 1.2;
<span class="linenr">290: </span>    cx.beginPath();
<span class="linenr">291: </span>    cx.moveTo(nearest_node.x, nearest_node.y);
<span class="linenr">292: </span>    cx.lineTo(new_node.x, new_node.y);
<span class="linenr">293: </span>    cx.stroke();
<span class="linenr">294: </span>    cx.closePath();
<span class="linenr">295: </span>  }
<span class="linenr">296: </span>}
<span class="linenr">297: </span><span class="org-keyword">let</span> <span class="org-variable-name">node_circle</span> = <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: new_node, radius: 1.2, fill: <span class="org-constant">true</span>, border_color: NODE_COLOR}); 
<span class="linenr">298: </span><span class="org-keyword">if</span> (unfulfilled_promise) {
<span class="linenr">299: </span>  cx.beginPath();
<span class="linenr">300: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">center=(x,y) radius=r angle=0 to 7        </span>
<span class="linenr">301: </span>  cx.arc(node_circle.center.x, node_circle.center.y, node_circle.radius, 0, 7);
<span class="linenr">302: </span>  cx.fillStyle = node_circle.fill_color;
<span class="linenr">303: </span>  cx.fill();
<span class="linenr">304: </span>  cx.closePath();
<span class="linenr">305: </span>}
</pre>
</div>
<p>
Finally we need to check and see if the new node is close enough to are target destination. Otherwise, we'll continue searching.
</p>

<div class="org-src-container">
<pre class="src src-js" id="org784cc9b"><span class="linenr">305: </span>    <span class="org-keyword">if</span> (distance(new_node, objects[1].center) &lt; PROXIMITY_THRESHOLD &amp;&amp; unfulfilled_promise) {
<span class="linenr">306: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">node</span> = new_node;
<span class="linenr">307: </span>      path = [];
<span class="linenr">308: </span>      <span class="org-keyword">while</span> (node <span class="org-keyword">instanceof</span> <span class="org-type">PathNode</span>) {
<span class="linenr">309: </span>        path.push(node);
<span class="linenr">310: </span>        node = node.parent;
<span class="linenr">311: </span>      }
<span class="linenr">312: </span>      resolve(0);
<span class="linenr">313: </span>      unfulfilled_promise = <span class="org-constant">false</span>;
<span class="linenr">314: </span>    }
<span class="linenr">315: </span>  }
<span class="linenr">316: </span>
<span class="linenr">317: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">delete sample circle</span>
<span class="linenr">318: </span>  cx2.clearRect(0, 0, layer2.width, layer2.height);        
<span class="linenr">319: </span>
<span class="linenr">320: </span>  iterations += 1;        
<span class="linenr">321: </span>}  
<span class="linenr">322: </span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orge315482" class="outline-2">
<h2 id="orge315482">Source Code</h2>
<div class="outline-text-2" id="text-orge315482">
<p>
Below is the whole thing put together.
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="linenr">  0: </span>Promise.config({
<span class="linenr">  1: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Enable warnings</span>
<span class="linenr">  2: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">warnings: true,</span>
<span class="linenr">  3: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Enable long stack traces</span>
<span class="linenr">  4: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">longStackTraces: true,</span>
<span class="linenr">  5: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Enable cancellation</span>
<span class="linenr">  6: </span>  cancellation: <span class="org-constant">true</span>,
<span class="linenr">  7: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Enable monitoring</span>
<span class="linenr">  8: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">monitoring: true,</span>
<span class="linenr">  9: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">Enable async hooks</span>
<span class="linenr"> 10: </span>  <span class="org-comment-delimiter">// </span><span class="org-comment">asyncHooks: true,</span>
<span class="linenr"> 11: </span>});
<span class="linenr"> 12: </span>
<span class="linenr"> 13: </span>document.addEventListener(<span class="org-string">"DOMContentLoaded"</span>, () =&gt; {
<span class="linenr"> 14: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">width</span> = window.innerWidth &gt; 450 ? 400 : window.innerWidth - 50;
<span class="linenr"> 15: </span>  CanvasRRT({
<span class="linenr"> 16: </span>    canvas_container: document.querySelector(<span class="org-string">'#grid-container'</span>),
<span class="linenr"> 17: </span>    width: window.innerWidth &gt; 450 ? 400 : window.innerWidth - 75,
<span class="linenr"> 18: </span>    height: 400,
<span class="linenr"> 19: </span>    objects: [
<span class="linenr"> 20: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 10, y: 391 }, radius: 10, border_color: <span class="org-string">"#d63230"</span>, border_width: 0}),
<span class="linenr"> 21: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: width - 40, y: 10 }, radius: 10, border_color: <span class="org-string">"#d63230"</span>, border_width: 0}),
<span class="linenr"> 22: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 294, y: 150 }, radius: 40, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>}),
<span class="linenr"> 23: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 164, y: 269 }, radius: 40, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>}),
<span class="linenr"> 24: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 179, y: 152 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 25: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 69, y: 80 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 26: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 138, y: 67 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 27: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 217, y: 92 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 28: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 306, y: 64 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 29: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 261, y: 231 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 30: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 340, y: 241 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 31: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 310, y: 365 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 32: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 248, y: 310 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 33: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 66, y: 160 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 34: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 65, y: 249 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 35: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 97, y: 323 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 36: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 183, y: 343 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 37: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 125, y: 195 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 38: </span>      <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: { x: 325, y: 322 }, radius: 30, border_color: <span class="org-string">"black"</span>, fill_color: <span class="org-string">"#79a5a5"</span>, }),
<span class="linenr"> 39: </span>    ],
<span class="linenr"> 40: </span>    speed_slider: document.querySelector(<span class="org-string">'input#speed'</span>),
<span class="linenr"> 41: </span>    instant_checkbox: document.getElementById(<span class="org-string">'instant'</span>),
<span class="linenr"> 42: </span>  });
<span class="linenr"> 43: </span>});
<span class="linenr"> 44: </span>
<span class="linenr"> 45: </span><span class="org-keyword">const</span> <span class="org-variable-name">BACKGROUND_COLOR</span> = <span class="org-string">"#008b8b"</span>;
<span class="linenr"> 46: </span><span class="org-keyword">const</span> <span class="org-variable-name">NODE_COLOR</span> = <span class="org-string">"#5fcbcb"</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">#E7E438</span>
<span class="linenr"> 47: </span><span class="org-keyword">const</span> <span class="org-variable-name">TREE_COLOR</span> = <span class="org-string">"#5fcbcb"</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">#fac50e</span>
<span class="linenr"> 48: </span>
<span class="linenr"> 49: </span><span class="org-keyword">class</span> Circle {
<span class="linenr"> 50: </span>  constructor({ center, radius, border_color, border_width=4, fill_color=border_color }) {
<span class="linenr"> 51: </span>    <span class="org-constant">this</span>.center = center;
<span class="linenr"> 52: </span>    <span class="org-constant">this</span>.radius = radius;
<span class="linenr"> 53: </span>    <span class="org-constant">this</span>.border_color = border_color;
<span class="linenr"> 54: </span>    <span class="org-constant">this</span>.fill_color = fill_color;
<span class="linenr"> 55: </span>    <span class="org-constant">this</span>.border_width = border_width;
<span class="linenr"> 56: </span>  }
<span class="linenr"> 57: </span>
<span class="linenr"> 58: </span>  within(x, y) {
<span class="linenr"> 59: </span>    <span class="org-keyword">return</span> distance({ x, y }, <span class="org-constant">this</span>.center) &lt;= <span class="org-constant">this</span>.radius;
<span class="linenr"> 60: </span>  }
<span class="linenr"> 61: </span>}
<span class="linenr"> 62: </span>
<span class="linenr"> 63: </span><span class="org-keyword">function</span> <span class="org-function-name">distance</span>(<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>) {
<span class="linenr"> 64: </span>  <span class="org-keyword">return</span> Math.sqrt(Math.pow(b.y - a.y, 2) + Math.pow(b.x - a.x, 2));
<span class="linenr"> 65: </span>}
<span class="linenr"> 66: </span>
<span class="linenr"> 67: </span><span class="org-keyword">class</span> PathNode {
<span class="linenr"> 68: </span>  constructor(x, y, parent = <span class="org-constant">null</span>) {
<span class="linenr"> 69: </span>    <span class="org-constant">this</span>.x = x;
<span class="linenr"> 70: </span>    <span class="org-constant">this</span>.y = y;
<span class="linenr"> 71: </span>    <span class="org-constant">this</span>.parent = parent;
<span class="linenr"> 72: </span>  } 
<span class="linenr"> 73: </span>}
<span class="linenr"> 74: </span>
<span class="linenr"> 75: </span><span class="org-keyword">function</span> <span class="org-function-name">calc_waypoints</span>(<span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>, <span class="org-variable-name">n</span>) {
<span class="linenr"> 76: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">waypoints</span> = [];
<span class="linenr"> 77: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">dx</span> = b.x - a.x;
<span class="linenr"> 78: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">dy</span> = b.y - a.y;
<span class="linenr"> 79: </span>
<span class="linenr"> 80: </span>  <span class="org-keyword">for</span> (<span class="org-keyword">let</span> <span class="org-variable-name">j</span> = 0; j &lt; n; j++) {
<span class="linenr"> 81: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = a.x + dx * j / n;
<span class="linenr"> 82: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = a.y + dy * j / n;
<span class="linenr"> 83: </span>    waypoints.push({ x, y });
<span class="linenr"> 84: </span>  }
<span class="linenr"> 85: </span>  <span class="org-keyword">return</span> waypoints;
<span class="linenr"> 86: </span>}
<span class="linenr"> 87: </span>
<span class="linenr"> 88: </span><span class="org-keyword">const</span> <span class="org-variable-name">sleep</span> = <span class="org-keyword">async</span> ms =&gt; <span class="org-keyword">new</span> <span class="org-type">Promise</span>(r =&gt; setTimeout(r, ms));
<span class="linenr"> 89: </span>
<span class="linenr"> 90: </span><span class="org-keyword">async</span> <span class="org-keyword">function</span> CanvasRRT ({ canvas_container, width, height, objects, speed_slider, instant_checkbox }) {
<span class="linenr"> 91: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">canvas</span> = document.createElement(<span class="org-string">'canvas'</span>);
<span class="linenr"> 92: </span>  canvas.style.border = <span class="org-string">"6px solid black"</span>;
<span class="linenr"> 93: </span>  canvas.style.touchAction = <span class="org-string">'none'</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Prevent scroll on touch screen devices.</span>
<span class="linenr"> 94: </span>  canvas.width = width;
<span class="linenr"> 95: </span>  canvas.height = height;
<span class="linenr"> 96: </span>  canvas.style.position = <span class="org-string">"absolute"</span>;
<span class="linenr"> 97: </span>  canvas.style.left = 0;
<span class="linenr"> 98: </span>  canvas.style.top = 0;
<span class="linenr"> 99: </span>  canvas.style.zIndex = 0;
<span class="linenr">100: </span>
<span class="linenr">101: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">layer2</span> = document.createElement(<span class="org-string">'canvas'</span>);
<span class="linenr">102: </span>  layer2.style.border = <span class="org-string">"6px solid black"</span>;
<span class="linenr">103: </span>  layer2.style.touchAction = <span class="org-string">'none'</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">Prevent scroll on touch screen devices.</span>
<span class="linenr">104: </span>  layer2.width = width;
<span class="linenr">105: </span>  layer2.height = height;
<span class="linenr">106: </span>  layer2.style.position = <span class="org-string">"absolute"</span>;
<span class="linenr">107: </span>  layer2.style.left = 0;
<span class="linenr">108: </span>  layer2.style.top = 0;
<span class="linenr">109: </span>  layer2.style.zIndex = 1;
<span class="linenr">110: </span>
<span class="linenr">111: </span>  canvas_container.appendChild(canvas);
<span class="linenr">112: </span>  canvas_container.appendChild(layer2);
<span class="linenr">113: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">cx</span> = canvas.getContext(<span class="org-string">"2d"</span>);
<span class="linenr">114: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">cx2</span> = layer2.getContext(<span class="org-string">"2d"</span>);
<span class="linenr">115: </span>
<span class="linenr">116: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">render_grid</span> = () =&gt; {  
<span class="linenr">117: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">draw canvas background</span>
<span class="linenr">118: </span>    cx.fillStyle = BACKGROUND_COLOR; <span class="org-comment-delimiter">// </span><span class="org-comment">blue green</span>
<span class="linenr">119: </span>    cx.fillRect(0, 0, width, height);
<span class="linenr">120: </span>
<span class="linenr">121: </span>    <span class="org-comment-delimiter">// </span><span class="org-comment">draw objects</span>
<span class="linenr">122: </span>    objects.forEach(object =&gt; {
<span class="linenr">123: </span>      cx.beginPath();
<span class="linenr">124: </span>      <span class="org-comment-delimiter">// </span><span class="org-comment">center=(x,y) radius=r angle=0 to 7</span>
<span class="linenr">125: </span>      cx.arc(object.center.x, object.center.y, object.radius - object.border_width / 2, 0, 7);
<span class="linenr">126: </span>      cx.fillStyle = object.fill_color;    
<span class="linenr">127: </span>      cx.fill();
<span class="linenr">128: </span>
<span class="linenr">129: </span>      cx.lineWidth = object.border_width;
<span class="linenr">130: </span>      cx.strokeStyle = object.border_color;
<span class="linenr">131: </span>      cx.stroke();
<span class="linenr">132: </span>
<span class="linenr">133: </span>      cx.closePath();
<span class="linenr">134: </span>    });
<span class="linenr">135: </span>  }
<span class="linenr">136: </span>
<span class="linenr">137: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">object_grabbed_idx</span> = -1;
<span class="linenr">138: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">object_hovered_idx</span> = -1;
<span class="linenr">139: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">clicked_on</span> = <span class="org-constant">false</span>;
<span class="linenr">140: </span>
<span class="linenr">141: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">press_handler</span> = e =&gt; {
<span class="linenr">142: </span>    e.stopPropagation();
<span class="linenr">143: </span>    e.preventDefault();
<span class="linenr">144: </span>    clicked_on = <span class="org-constant">true</span>;
<span class="linenr">145: </span>    object_grabbed_idx = objects.reduce((res, object, current_idx) =&gt; {
<span class="linenr">146: </span>      <span class="org-keyword">return</span> object.within(e.offsetX, e.offsetY) ?  current_idx : res;
<span class="linenr">147: </span>    }, -1); <span class="org-comment-delimiter">// </span><span class="org-comment">-1 indicates no object grabbed</span>
<span class="linenr">148: </span>
<span class="linenr">149: </span>    object_hovered_idx = object_grabbed_idx;
<span class="linenr">150: </span>    <span class="org-keyword">if</span> (object_grabbed_idx != -1) {
<span class="linenr">151: </span>      layer2.style.cursor = <span class="org-string">"grabbing"</span>;
<span class="linenr">152: </span>    }
<span class="linenr">153: </span>  };
<span class="linenr">154: </span>
<span class="linenr">155: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">move_handler</span> = e =&gt; {
<span class="linenr">156: </span>    e.stopPropagation();
<span class="linenr">157: </span>    e.preventDefault();
<span class="linenr">158: </span>
<span class="linenr">159: </span>    <span class="org-keyword">if</span> (object_grabbed_idx == -1) {
<span class="linenr">160: </span>      object_hovered_idx = objects.reduce((res, object, current_idx) =&gt; {
<span class="linenr">161: </span>        <span class="org-keyword">return</span> object.within(e.offsetX, e.offsetY) ?  current_idx : res;
<span class="linenr">162: </span>      }, -1); <span class="org-comment-delimiter">// </span><span class="org-comment">-1 indicates no object hovered over</span>
<span class="linenr">163: </span>      <span class="org-keyword">if</span> (object_hovered_idx == -1) {
<span class="linenr">164: </span>        layer2.style.cursor = <span class="org-string">"crosshair"</span>
<span class="linenr">165: </span>      } <span class="org-keyword">else</span> {
<span class="linenr">166: </span>        layer2.style.cursor = <span class="org-string">"grab"</span>
<span class="linenr">167: </span>      }
<span class="linenr">168: </span>
<span class="linenr">169: </span>      <span class="org-keyword">return</span>;
<span class="linenr">170: </span>    }
<span class="linenr">171: </span>
<span class="linenr">172: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">x</span> = e.offsetX;
<span class="linenr">173: </span>    <span class="org-keyword">let</span> <span class="org-variable-name">y</span> = e.offsetY;
<span class="linenr">174: </span>    <span class="org-keyword">if</span> (x &lt; 0 || y &lt; 0 || x &gt;= canvas.width || y &gt;= canvas.height) {
<span class="linenr">175: </span>      <span class="org-keyword">return</span>;
<span class="linenr">176: </span>    }
<span class="linenr">177: </span>
<span class="linenr">178: </span>    objects[object_grabbed_idx].center = { x, y };
<span class="linenr">179: </span>    render_grid();
<span class="linenr">180: </span>  };
<span class="linenr">181: </span>
<span class="linenr">182: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">path</span>;
<span class="linenr">183: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">RRT</span> = () =&gt; {
<span class="linenr">184: </span>    <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">Promise</span>(<span class="org-keyword">async</span> (resolve, reject, onCancel) =&gt; {
<span class="linenr">185: </span>      <span class="org-keyword">const</span> <span class="org-variable-name">MAX_BRANCH_LENGTH</span> = 20;
<span class="linenr">186: </span>      <span class="org-keyword">const</span> <span class="org-variable-name">PROXIMITY_THRESHOLD</span> = 10;
<span class="linenr">187: </span>      <span class="org-keyword">const</span> <span class="org-variable-name">MAX_ITERATIONS</span> = 5000;
<span class="linenr">188: </span>
<span class="linenr">189: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">path_nodes</span> = [<span class="org-keyword">new</span> <span class="org-type">PathNode</span>(objects[0].center.x, objects[0].center.y)];
<span class="linenr">190: </span>
<span class="linenr">191: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">iterations</span> = 0;
<span class="linenr">192: </span>      <span class="org-keyword">let</span> <span class="org-variable-name">unfulfilled_promise</span> = <span class="org-constant">true</span>;
<span class="linenr">193: </span>      onCancel(<span class="org-keyword">function</span>() {
<span class="linenr">194: </span>        unfulfilled_promise = <span class="org-constant">false</span>;
<span class="linenr">195: </span>      });
<span class="linenr">196: </span>      <span class="org-keyword">while</span> (iterations &lt;= MAX_ITERATIONS &amp;&amp; unfulfilled_promise) {
<span class="linenr">197: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">randomly sample a point, (xs, ys) </span>
<span class="linenr">198: </span>        <span class="org-keyword">let</span> [<span class="org-variable-name">xs</span>, <span class="org-variable-name">ys</span>] = [Math.random() * canvas.width, Math.random() * canvas.height];
<span class="linenr">199: </span>
<span class="linenr">200: </span>        <span class="org-keyword">if</span> (!instant_checkbox.checked &amp;&amp; unfulfilled_promise) {
<span class="linenr">201: </span>          <span class="org-comment-delimiter">// </span><span class="org-comment">display sample spot</span>
<span class="linenr">202: </span>          <span class="org-keyword">let</span> <span class="org-variable-name">sample_circle</span> = <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: {x: xs, y: ys}, radius: 3, fill: <span class="org-constant">true</span>, border_color: <span class="org-string">"red"</span>});
<span class="linenr">203: </span>          cx2.beginPath(); 
<span class="linenr">204: </span>          <span class="org-comment-delimiter">// </span><span class="org-comment">center=(x,y) radius=r angle=0 to 7 </span>
<span class="linenr">205: </span>          cx2.arc(sample_circle.center.x, sample_circle.center.y, sample_circle.radius, 0, 7);
<span class="linenr">206: </span>          cx2.fillStyle = sample_circle.fill_color;
<span class="linenr">207: </span>          cx2.fill();
<span class="linenr">208: </span>          cx2.closePath();
<span class="linenr">209: </span>        }
<span class="linenr">210: </span>
<span class="linenr">211: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">Find the nearest node in the tree</span>
<span class="linenr">212: </span>        <span class="org-keyword">let</span> <span class="org-variable-name">nearest_node</span> = path_nodes.reduce((nearest, node) =&gt; {
<span class="linenr">213: </span>          <span class="org-keyword">return</span> distance(node, { x: xs, y: ys }) &lt; distance(nearest, { x: xs, y: ys }) ? node : nearest;
<span class="linenr">214: </span>        });
<span class="linenr">215: </span>        <span class="org-keyword">const</span> <span class="org-variable-name">dx</span> = xs - nearest_node.x;
<span class="linenr">216: </span>        <span class="org-keyword">const</span> <span class="org-variable-name">dy</span> = ys - nearest_node.y;
<span class="linenr">217: </span>        <span class="org-keyword">const</span> <span class="org-variable-name">magnitude</span> = Math.sqrt(dx**2 + dy**2);
<span class="linenr">218: </span>        <span class="org-keyword">const</span> <span class="org-variable-name">ux</span> = dx / magnitude;
<span class="linenr">219: </span>        <span class="org-keyword">const</span> <span class="org-variable-name">uy</span> = dy / magnitude;
<span class="linenr">220: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">r(t) is the vector equation of a line through the nearest node and the sampled point</span>
<span class="linenr">221: </span>        <span class="org-comment-delimiter">//        </span><span class="org-comment">&#9115;x &#9118;     &#9115;u &#9118;</span>
<span class="linenr">222: </span>        <span class="org-comment-delimiter">//        </span><span class="org-comment">&#9116; 0&#9119;     &#9116; x&#9119;</span>
<span class="linenr">223: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">r(t) = &#9116;  &#9119; + t &#9116;  &#9119;</span>
<span class="linenr">224: </span>        <span class="org-comment-delimiter">//        </span><span class="org-comment">&#9116;y &#9119;     &#9116;u &#9119;</span>
<span class="linenr">225: </span>        <span class="org-comment-delimiter">//        </span><span class="org-comment">&#9117; 0&#9120;     &#9117; y&#9120;</span>
<span class="linenr">226: </span>
<span class="linenr">227: </span>        <span class="org-keyword">const</span> <span class="org-variable-name">r</span> = t =&gt; {          
<span class="linenr">228: </span>          <span class="org-keyword">return</span> [ ux * t + nearest_node.x, uy * t + nearest_node.y ];
<span class="linenr">229: </span>        };
<span class="linenr">230: </span>
<span class="linenr">231: </span>        <span class="org-keyword">let</span> <span class="org-variable-name">ts</span> = []; <span class="org-comment-delimiter">// </span><span class="org-comment">t values at intersections between r(t) and the circles</span>
<span class="linenr">232: </span>        <span class="org-keyword">if</span> (unfulfilled_promise) {
<span class="linenr">233: </span>          objects.slice(2).forEach(circle =&gt; {
<span class="linenr">234: </span>            <span class="org-keyword">const</span> <span class="org-variable-name">cx</span> = circle.center.x;
<span class="linenr">235: </span>            <span class="org-keyword">const</span> <span class="org-variable-name">cy</span> = circle.center.y;
<span class="linenr">236: </span>            <span class="org-keyword">const</span> <span class="org-variable-name">x0</span> = nearest_node.x;
<span class="linenr">237: </span>            <span class="org-keyword">const</span> <span class="org-variable-name">y0</span> = nearest_node.y;
<span class="linenr">238: </span>            <span class="org-keyword">const</span> <span class="org-variable-name">rc</span> = circle.radius;
<span class="linenr">239: </span>            <span class="org-keyword">const</span> <span class="org-variable-name">under_root</span> = -(cx**2) * uy**2 + 2 * cx * cy * ux * uy - 2 * cx * ux * uy * y0 + 2 * cx * uy**2 * x0 - cy**2 * ux**2 + 2 * cy * ux**2 * y0 - 2 * cy * ux * uy * x0 + ux**2 * rc**2 + rc**2 * uy**2 - ux**2 * y0**2 + 2 * ux * uy * x0 * y0 - uy**2 * x0**2;
<span class="linenr">240: </span>            <span class="org-keyword">if</span> (under_root &lt; 0) {           
<span class="linenr">241: </span>              <span class="org-keyword">return</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">no intersection</span>
<span class="linenr">242: </span>            }
<span class="linenr">243: </span>
<span class="linenr">244: </span>            <span class="org-comment-delimiter">// </span><span class="org-comment">now we need to know if it has a solution on a range of t</span>
<span class="linenr">245: </span>            <span class="org-keyword">let</span> <span class="org-variable-name">a</span> = cx * ux + cy * uy - ux * x0 - uy * y0;
<span class="linenr">246: </span>            <span class="org-keyword">let</span> <span class="org-variable-name">denom</span> = ux**2 + uy**2;
<span class="linenr">247: </span>            <span class="org-keyword">let</span> <span class="org-variable-name">t1</span> = (a - Math.sqrt(under_root)) / denom;
<span class="linenr">248: </span>            <span class="org-keyword">let</span> <span class="org-variable-name">t2</span> = (a + Math.sqrt(under_root)) / denom;
<span class="linenr">249: </span>            <span class="org-keyword">let</span> <span class="org-variable-name">tsi</span> = [t1, t2];
<span class="linenr">250: </span>            tsi.forEach(t =&gt; {
<span class="linenr">251: </span>              <span class="org-keyword">if</span> (t &gt; 0 &amp;&amp; t &lt; MAX_BRANCH_LENGTH) {
<span class="linenr">252: </span>                ts.push(t);
<span class="linenr">253: </span>              }         
<span class="linenr">254: </span>            });
<span class="linenr">255: </span>          });  
<span class="linenr">256: </span>        }
<span class="linenr">257: </span>
<span class="linenr">258: </span>        <span class="org-keyword">let</span> <span class="org-variable-name">tn</span> = Math.min(...ts, MAX_BRANCH_LENGTH, distance(nearest_node, { x: xs, y: ys })) - 0.2;
<span class="linenr">259: </span>
<span class="linenr">260: </span>        <span class="org-keyword">if</span> (objects.slice(2).every(circle =&gt; !circle.within(...r(tn)))) {       
<span class="linenr">261: </span>          <span class="org-keyword">const</span> <span class="org-variable-name">new_node</span> = <span class="org-keyword">new</span> <span class="org-type">PathNode</span>(...r(tn), nearest_node);
<span class="linenr">262: </span>          path_nodes.push(new_node);
<span class="linenr">263: </span>
<span class="linenr">264: </span>          <span class="org-keyword">if</span> (!instant_checkbox.checked) {
<span class="linenr">265: </span>            <span class="org-keyword">const</span> <span class="org-variable-name">n_waypoints</span> = 2**(10-speed_slider.value);
<span class="linenr">266: </span>            <span class="org-keyword">const</span> <span class="org-variable-name">waypoints</span> = calc_waypoints(nearest_node, new_node, n_waypoints);
<span class="linenr">267: </span>            <span class="org-keyword">for</span> (<span class="org-keyword">let</span> <span class="org-variable-name">t</span> = 1; t &lt; waypoints.length; t++) {
<span class="linenr">268: </span>              <span class="org-keyword">const</span> <span class="org-variable-name">a</span> = waypoints[t-1];
<span class="linenr">269: </span>              <span class="org-keyword">const</span> <span class="org-variable-name">b</span> = waypoints[t];
<span class="linenr">270: </span>
<span class="linenr">271: </span>              <span class="org-keyword">await</span> sleep(0);
<span class="linenr">272: </span>
<span class="linenr">273: </span>              requestAnimationFrame(_ =&gt; {
<span class="linenr">274: </span>                <span class="org-keyword">if</span> (unfulfilled_promise) {
<span class="linenr">275: </span>                  cx.strokeStyle = TREE_COLOR;
<span class="linenr">276: </span>                  cx.lineWidth = 1.2;
<span class="linenr">277: </span>                  cx.beginPath();
<span class="linenr">278: </span>                  cx.moveTo(a.x, a.y);
<span class="linenr">279: </span>                  cx.lineTo(b.x, b.y);
<span class="linenr">280: </span>                  cx.stroke();
<span class="linenr">281: </span>                  cx.closePath();
<span class="linenr">282: </span>                }
<span class="linenr">283: </span>              });
<span class="linenr">284: </span>            }
<span class="linenr">285: </span>          } <span class="org-keyword">else</span> {
<span class="linenr">286: </span>            <span class="org-keyword">if</span> (unfulfilled_promise) {
<span class="linenr">287: </span>              cx.strokeStyle = TREE_COLOR;
<span class="linenr">288: </span>              cx.lineWidth = 1.2;
<span class="linenr">289: </span>              cx.beginPath();
<span class="linenr">290: </span>              cx.moveTo(nearest_node.x, nearest_node.y);
<span class="linenr">291: </span>              cx.lineTo(new_node.x, new_node.y);
<span class="linenr">292: </span>              cx.stroke();
<span class="linenr">293: </span>              cx.closePath();
<span class="linenr">294: </span>            }
<span class="linenr">295: </span>          }
<span class="linenr">296: </span>          <span class="org-keyword">let</span> <span class="org-variable-name">node_circle</span> = <span class="org-keyword">new</span> <span class="org-type">Circle</span>({ center: new_node, radius: 1.2, fill: <span class="org-constant">true</span>, border_color: NODE_COLOR}); 
<span class="linenr">297: </span>          <span class="org-keyword">if</span> (unfulfilled_promise) {
<span class="linenr">298: </span>            cx.beginPath();
<span class="linenr">299: </span>            <span class="org-comment-delimiter">// </span><span class="org-comment">center=(x,y) radius=r angle=0 to 7        </span>
<span class="linenr">300: </span>            cx.arc(node_circle.center.x, node_circle.center.y, node_circle.radius, 0, 7);
<span class="linenr">301: </span>            cx.fillStyle = node_circle.fill_color;
<span class="linenr">302: </span>            cx.fill();
<span class="linenr">303: </span>            cx.closePath();
<span class="linenr">304: </span>          }
<span class="linenr">305: </span>
<span class="linenr">306: </span>          <span class="org-keyword">if</span> (distance(new_node, objects[1].center) &lt; PROXIMITY_THRESHOLD &amp;&amp; unfulfilled_promise) {
<span class="linenr">307: </span>            <span class="org-keyword">let</span> <span class="org-variable-name">node</span> = new_node;
<span class="linenr">308: </span>            path = [];
<span class="linenr">309: </span>            <span class="org-keyword">while</span> (node <span class="org-keyword">instanceof</span> <span class="org-type">PathNode</span>) {
<span class="linenr">310: </span>              path.push(node);
<span class="linenr">311: </span>              node = node.parent;
<span class="linenr">312: </span>            }
<span class="linenr">313: </span>            resolve(0);
<span class="linenr">314: </span>            unfulfilled_promise = <span class="org-constant">false</span>;
<span class="linenr">315: </span>          }
<span class="linenr">316: </span>        }
<span class="linenr">317: </span>
<span class="linenr">318: </span>        <span class="org-comment-delimiter">// </span><span class="org-comment">delete sample circle</span>
<span class="linenr">319: </span>        cx2.clearRect(0, 0, layer2.width, layer2.height);        
<span class="linenr">320: </span>
<span class="linenr">321: </span>        iterations += 1;        
<span class="linenr">322: </span>      }  
<span class="linenr">323: </span>
<span class="linenr">324: </span>      reject(<span class="org-keyword">new</span> <span class="org-type">Error</span>(<span class="org-string">"Iteration limit reached"</span>));
<span class="linenr">325: </span>      unfulfilled_promise = <span class="org-constant">false</span>;
<span class="linenr">326: </span>    });
<span class="linenr">327: </span>  };
<span class="linenr">328: </span>
<span class="linenr">329: </span>  <span class="org-keyword">let</span> <span class="org-variable-name">RRT_promise</span>;
<span class="linenr">330: </span>
<span class="linenr">331: </span>  <span class="org-keyword">const</span> <span class="org-variable-name">unclick_handler</span> = e =&gt; {
<span class="linenr">332: </span>    <span class="org-keyword">if</span> (!clicked_on) { <span class="org-comment-delimiter">// </span><span class="org-comment">the user may be unclicking off      </span>
<span class="linenr">333: </span>      <span class="org-keyword">return</span>;          <span class="org-comment-delimiter">// </span><span class="org-comment">the canvas after clicking and </span>
<span class="linenr">334: </span>    }                  <span class="org-comment-delimiter">// </span><span class="org-comment">dragging on the canvas</span>
<span class="linenr">335: </span>
<span class="linenr">336: </span>    <span class="org-keyword">if</span> (RRT_promise) {
<span class="linenr">337: </span>      RRT_promise.cancel();
<span class="linenr">338: </span>    }
<span class="linenr">339: </span>
<span class="linenr">340: </span>    render_grid();
<span class="linenr">341: </span>    object_grabbed_idx = -1;
<span class="linenr">342: </span>    layer2.style.cursor = object_hovered_idx == -1 ? <span class="org-string">"crosshair"</span> : <span class="org-string">"grab"</span>;
<span class="linenr">343: </span>
<span class="linenr">344: </span>    RRT_promise = RRT();
<span class="linenr">345: </span>    RRT_promise.then(err =&gt; {
<span class="linenr">346: </span>      <span class="org-keyword">if</span> (err == 0) {
<span class="linenr">347: </span>        cx.strokeStyle = <span class="org-string">"#d63230"</span>;
<span class="linenr">348: </span>        cx.lineWidth = 3; 
<span class="linenr">349: </span>        cx.lineJoin = <span class="org-string">"round"</span>;
<span class="linenr">350: </span>        cx.beginPath();
<span class="linenr">351: </span>        cx.moveTo(path[0].x, path[0].y);
<span class="linenr">352: </span>        path.forEach(node =&gt; {
<span class="linenr">353: </span>          cx.lineTo(node.x, node.y);
<span class="linenr">354: </span>        });
<span class="linenr">355: </span>        cx.stroke();
<span class="linenr">356: </span>      }
<span class="linenr">357: </span>    });
<span class="linenr">358: </span>
<span class="linenr">359: </span>    clicked_on = <span class="org-constant">false</span>;
<span class="linenr">360: </span>  };
<span class="linenr">361: </span>
<span class="linenr">362: </span>  layer2.addEventListener(<span class="org-string">'mousedown'</span>, press_handler, <span class="org-constant">true</span>);
<span class="linenr">363: </span>  layer2.addEventListener(<span class="org-string">'pointerdown'</span>, press_handler, <span class="org-constant">true</span>);
<span class="linenr">364: </span>  layer2.addEventListener(<span class="org-string">'mousemove'</span>, move_handler, <span class="org-constant">true</span>);
<span class="linenr">365: </span>  layer2.addEventListener(<span class="org-string">'pointermove'</span>, move_handler, <span class="org-constant">true</span>);
<span class="linenr">366: </span>  window.addEventListener(<span class="org-string">'mouseup'</span>, unclick_handler, <span class="org-constant">true</span>);      
<span class="linenr">367: </span>  window.addEventListener(<span class="org-string">'pointerup'</span>, unclick_handler, <span class="org-constant">true</span>);
<span class="linenr">368: </span>
<span class="linenr">369: </span>  clicked_on = <span class="org-constant">true</span>;
<span class="linenr">370: </span>  unclick_handler();
<span class="linenr">371: </span>}
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
Annoyingly, JavaScript provides no method for cancelling a Promise. So, I'm using a third party library called <a href="http://bluebirdjs.com/docs/getting-started.html">bluebird.js</a>.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Date: 2023-03-19 Sun 00:00</p>
</div>
</body>
</html>