<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Huffman Encoding Explainer</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="/stylesheets/color-scheme.css"/>
<link rel="stylesheet" type="text/css" href="/stylesheets/layout-blog.css"/>
<link rel="stylesheet" type="text/css" href="/stylesheets/blog-post.css"/>
<link rel="stylesheet" type="text/css" href="/stylesheets/htmlize2.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script src="/javascripts/htmlize.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<header>
    <nav>
        <a target="_self" href="/">About</a> -
        <a target="_self" href="/blog-posts.html">Blog</a> |
        <!-- <a target="_self" href="/portfolio.html">Portfolio</a> -         -->
        <!-- <a target="_self" href="/contact.html">Contact</a> - -->
        <!-- <a target="_self" href="/resume.html">Resume</a> | -->
        <a target="_blank" rel="noopener noreferrer" href="https://duncan-britt.github.io/splice-docs">Splice</a> -
        <a target="_blank" rel="noopener noreferrer" href="https://word-ladders.herokuapp.com/">Word Ladders</a>
        <!-- <a target="_blank" rel="noopener noreferrer" href="https://github.com/Duncan-Britt/">GitHub</a> -
             <a target="_blank" rel="noopener noreferrer" href="https://www.codewars.com/users/Duncan-Britt">Code Wars</a> -->
    </nav>
</header>
</div>
<div id="content" class="content">
<h1 class="title">Huffman Encoding Explainer</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1ba3a09">Fixed Length Encoding</a></li>
<li><a href="#org60a89d3">Huffman Encoding</a>
<ul>
<li><a href="#org336b244">Stepping through the algorithm</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
In this post I'll describe what Huffman Encoding is and walk you through the process of implementing it in Scala.
</p>

<div id="outline-container-org1ba3a09" class="outline-2">
<h2 id="org1ba3a09">Fixed Length Encoding</h2>
<div class="outline-text-2" id="text-org1ba3a09">
<p>
Suppose you have a string, such as <code>peter piper picked a peck of pickled peppers</code>, and you want to represent the string with as few bits as you can. There are 14 distinct characters in the string, namely \(\{\text{ },a,c,d,e,f,i,k,l,o,p,r,s,t\}\), which means that in order to represent this string with fixed length encoding, meaning that every character uses the same number of bits, you would need 4 bits per character, since \(2^4 = 16 \geq 14\) and \(2^3 = 8 < 14\), e.g.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">a</th>
<th scope="col" class="org-right">c</th>
<th scope="col" class="org-right">d</th>
<th scope="col" class="org-right">e</th>
<th scope="col" class="org-right">f</th>
<th scope="col" class="org-right">i</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0000</td>
<td class="org-right">0001</td>
<td class="org-right">0010</td>
<td class="org-right">0011</td>
<td class="org-right">0100</td>
<td class="org-right">0101</td>
<td class="org-right">0110</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">k</th>
<th scope="col" class="org-right">l</th>
<th scope="col" class="org-right">o</th>
<th scope="col" class="org-right">p</th>
<th scope="col" class="org-right">r</th>
<th scope="col" class="org-right">s</th>
<th scope="col" class="org-right">t</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0111</td>
<td class="org-right">1000</td>
<td class="org-right">1001</td>
<td class="org-right">1010</td>
<td class="org-right">1011</td>
<td class="org-right">1100</td>
<td class="org-right">1101</td>
</tr>
</tbody>
</table>

<p>
With 4 bits per character and 44 characters in our string, that gives us 176 bits needed to represent the string, as follows:
</p>
<div style="overflow-wrap: break-word;">10100100110101001011000010100110101001001011000010100110001001110100001100000001000010100100001001110000100101010000101001100010011110000100001100001010010010101010010010111100.</div>

<p>
But we can do better than that.
</p>
</div>
</div>

<div id="outline-container-org60a89d3" class="outline-2">
<h2 id="org60a89d3">Huffman Encoding</h2>
<div class="outline-text-2" id="text-org60a89d3">
<p>
Huffman encoding works by using variable length encoding and assigning the shortest bit strings to the least frequently used characters in the string. In order to ensure that there is no ambiguity about which character is being represented, the digits assigned to each character are built from a tree in which each character is at a leaf node, such that if you follow the tree down from the root node, you can be sure there is no other path on the tree which begins with the same digits. This will make more sense after seeing an example. We'll take the same string as before, <code>peter piper picked a peck of pickled peppers</code>, but find the huffman encoding of the string.
</p>

<p>
To start, we need to measure the frequency with which each character in \(\{\text{ },a,c,d,e,f,i,k,l,o,p,r,s,t\}\) appears.
</p>
<div class="org-src-container">
<pre class="src src-scala">val s = "peter piper picked a peck of pickled peppers"
val chars_freq_assoc = s.toSet                       // Get distinct characters.
  .map(c =&gt; {                                        // Transform the set of chars into
    (c, s.count(_ == c).toDouble / s.length.toDouble)// a set of tuples, e.g. ("a", 0.06)
  })                                                 
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ruby">s = <span class="org-string">"peter piper picked a peck of pickled peppers"</span>
chars_freq_assoc = s.chars.uniq.map <span class="org-keyword">do</span> |c|
  [c, s.count(c).to_f / s.length.to_f]
<span class="org-keyword">end</span>.sort_by <span class="org-keyword">do</span> |_, b|
  b
<span class="org-keyword">end</span>
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">f</td>
<td class="org-right">0.022727272727272728</td>
</tr>

<tr>
<td class="org-left">a</td>
<td class="org-right">0.022727272727272728</td>
</tr>

<tr>
<td class="org-left">o</td>
<td class="org-right">0.022727272727272728</td>
</tr>

<tr>
<td class="org-left">l</td>
<td class="org-right">0.022727272727272728</td>
</tr>

<tr>
<td class="org-left">t</td>
<td class="org-right">0.022727272727272728</td>
</tr>

<tr>
<td class="org-left">s</td>
<td class="org-right">0.022727272727272728</td>
</tr>

<tr>
<td class="org-left">d</td>
<td class="org-right">0.045454545454545456</td>
</tr>

<tr>
<td class="org-left">k</td>
<td class="org-right">0.06818181818181818</td>
</tr>

<tr>
<td class="org-left">r</td>
<td class="org-right">0.06818181818181818</td>
</tr>

<tr>
<td class="org-left">i</td>
<td class="org-right">0.06818181818181818</td>
</tr>

<tr>
<td class="org-left">c</td>
<td class="org-right">0.06818181818181818</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">0.1590909090909091</td>
</tr>

<tr>
<td class="org-left">e</td>
<td class="org-right">0.18181818181818182</td>
</tr>

<tr>
<td class="org-left">p</td>
<td class="org-right">0.20454545454545456</td>
</tr>
</tbody>
</table>

<p>
We're going to build up a tree that represents our Huffman encoding, where edges going to the left represent 0's and edges going to the right represent 1's. We define the tree type as follows.
</p>

<div class="org-src-container">
<pre class="src src-scala">// Define a tree type for the huffman encoding. Leaf nodes are Chr (characters), else Frq (frequencies)
sealed trait Tree
case class Chr(c: Char) extends Tree
case class Frq(f: Double, children: (Option[Tree], Option[Tree])) extends Tree
</pre>
</div>

<p>
Next we make subtrees of each character/frequency combo, and enqueue them all into a priority queue.
</p>

<div class="org-src-container">
<pre class="src src-scala">import scala.collection.mutable.PriorityQueue

// This is necessary for Scala's std. lib PriorityQueue type,
// Without this, our Priority Queue would be a max heap
// We define our Ordering to make it be a min heap
object OrderFrq extends Ordering[Frq] {
  def compare(x:Frq, y:Frq) = y.f compare x.f
}

val pq = new PriorityQueue[Frq]()(OrderFrq)

// Enqueue each member of the char_freq_assoc into the priority queue as Tree's.
// e.g. pq: {(0.06, a), (0.12, h), ...}
for (x &lt;- chars_freq_assoc) {
  pq.enqueue(Frq(x._2, (Some(Chr(x._1)), None)))
}
</pre>
</div>

<p>
At this point, we can dequeue two subtrees at a time from the priority queue, merge them into a subtree, and then enqueue the result back into our priority queue until there is only one subtree left in our priority queue, at which point that is our huffman tree.
</p>

<div class="org-src-container">
<pre class="src src-scala">while (pq.size &gt; 1) {
  val a:Frq = pq.dequeue
  val b:Frq = pq.dequeue
  // merge a and b into a subtree with frq of a + b, and enqueue it.
  pq.enqueue(Frq(a.f + b.f, (Some(a), Some(b))))
}

val huffman_tree = pq.dequeue
</pre>
</div>

<p>
To understand, let's walk through the steps of this algorithm.
</p>
</div>

<div id="outline-container-org336b244" class="outline-3">
<h3 id="org336b244">Stepping through the algorithm</h3>
<div class="outline-text-3" id="text-org336b244">
<ol class="org-ol">
<li>priority queue: \(\left((f, 0.023), (t, 0.023), (l, 0.023), (o, 0.023), (s, 0.023), (a, 0.023), (d, 0.045), (r, 0.068), (i, 0.068), (k, 0.068), (c, 0.068), ( , 0.159), (e, 0.182), (p, 0.205)\right)\)</li>

<li>\(\left((l, 0.023), (o, 0.023), (s, 0.023), (a, 0.023), (d, 0.045), (r, 0.068), (i, 0.068), (k, 0.068), (c, 0.068), ( , 0.159), (e, 0.182), (p, 0.205)\right)\)</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2023-09-24 Sun 00:00</p>
</div>
</body>
</html>
